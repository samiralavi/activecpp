{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>The <code>activecpp</code> repository provides an implementation of the Active Object design pattern in modern C++ (C++17 and newer). The primary purpose of this repository is to facilitate asynchronous and concurrent programming by decoupling method invocation from method execution. This is achieved by encapsulating an object's state and behavior in a separate thread, allowing clients to interact with the object through message passing.</p>"},{"location":"#key-features","title":"Key Features:","text":"<ul> <li>Single Header Implementation: The entire implementation is contained within a single header file, making it easy to integrate.</li> <li>Message Passing: Supports asynchronous delivery of messages of any type, maintaining the order in which they were sent.</li> <li>Lock-Free Queue: Utilizes an internal lock-free MPSC (Multiple Producer, Single Consumer) queue for efficient message handling.</li> <li>Callbacks and Timers: Provides mechanisms for invoking callbacks on clients of unknown types and managing timers with client-driven handlers.</li> <li>Performance: Designed for high performance, capable of handling several million messages per second between threads on ordinary hardware.</li> </ul>"},{"location":"#usage","title":"Usage:","text":"<ul> <li>Inheritance: Users create active objects by inheriting from the <code>ActorThread</code> template class.</li> <li>Message Handling: Implement <code>onMessage</code> methods to handle different types of messages.</li> <li>Thread Management: Use provided methods to manage the lifecycle of the active object, including starting, stopping, and sending messages.</li> </ul>"},{"location":"#example","title":"Example:","text":"<p>This example demonstrates the basic usage of <code>activecpp</code> to create an active object (consumer) that processes messages sent by a producer in a separate thread.</p> <pre><code>#include &lt;samiralavi/activecpp.h&gt;\n\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n\nusing namespace samiralavi;\n\n// Define a message structure\nstruct Message {\n    std::string description;\n};\n\n// Consumer class inheriting from ActorThread\nclass Consumer : public ActorThread&lt;Consumer&gt; {\n    friend ActorThread&lt;Consumer&gt;;\n\n    // Method to handle incoming messages\n    void onMessage(Message&amp; msg) {\n        std::cout &lt;&lt; \"Consumer thread \" &lt;&lt; std::this_thread::get_id()\n                  &lt;&lt; \" received message: \" &lt;&lt; msg.description &lt;&lt; std::endl;\n    }\n};\n\n// Producer function to send messages to the consumer\nvoid producer(Consumer&amp; consumer) {\n    for (int i = 0; i &lt; 5; ++i) {\n        // Create a message\n        Message msg{\"Message \" + std::to_string(i + 1)};\n\n        // Post the message to the consumer\n        consumer.post(std::move(msg));\n\n        // Sleep for a while to simulate work\n        std::this_thread::sleep_for(std::chrono::milliseconds(500));\n    }\n}\n\nint main() {\n    // Create a consumer object\n    Consumer consumer;\n\n    // Start the consumer thread\n    consumer.start();\n\n    // Create a producer thread\n    std::thread producerThread(producer, std::ref(consumer));\n\n    // Wait for the producer thread to finish\n    producerThread.join();\n\n    // Stop the consumer thread\n    consumer.stop();\n\n    return 0;\n}\n</code></pre>"},{"location":"#explanation","title":"Explanation:","text":"<ol> <li>Message Structure:</li> <li> <p>A simple <code>Message</code>struct is defined to hold the message data.</p> </li> <li> <p>Consumer Class:</p> </li> <li>The <code>Consumer</code> class inherits from <code>ActorThread&lt;Consumer&gt;</code>.</li> <li> <p>It implements the <code>onMessage</code> method to handle incoming <code>Message</code> objects.</p> </li> <li> <p>Producer Function:</p> </li> <li>The <code>producer</code> function sends a series of messages to the consumer.</li> <li>It uses the <code>post</code> method to send messages asynchronously.</li> <li> <p>The function simulates work by sleeping for 500 milliseconds between messages.</p> </li> <li> <p>Main Function:</p> </li> <li>A <code>Consumer</code> object is created and started.</li> <li>A producer thread is created to send messages to the consumer.</li> <li>The main thread waits for the producer thread to finish.</li> <li>Finally, the consumer thread is stopped.</li> </ol>"},{"location":"#documentation-and-build","title":"Documentation and Build:","text":"<ul> <li>Documentation: Comprehensive documentation is available, including design patterns and usage examples.</li> <li>Build System: Uses CMake for building and supports unit tests and examples.</li> </ul> <p>For more details, refer to the <code>README.md</code> and the documentation.</p>"},{"location":"active-object-pattern/","title":"Active Objects Design Pattern","text":""},{"location":"active-object-pattern/#introduction","title":"Introduction","text":"<p>The Active Object design pattern is a concurrency pattern that decouples method execution from method invocation to enhance the responsiveness and scalability of an application. This pattern is particularly useful in scenarios where multiple operations need to be performed concurrently without blocking the main thread of execution.</p>"},{"location":"active-object-pattern/#key-concepts","title":"Key Concepts","text":"<ol> <li>Proxy: The proxy provides an interface for clients to interact with the active object. It forwards method calls to the scheduler.</li> <li>Scheduler: The scheduler manages the execution of method requests. It maintains a queue of pending requests and dispatches them to the appropriate worker threads.</li> <li>Activation List: This is a queue where method requests are stored until they can be executed.</li> <li>Method Request: Each method request represents an operation to be performed by the active object. It encapsulates the method call and its parameters.</li> <li>Servant: The servant is the actual object that performs the requested operations. It contains the business logic.</li> <li>Future: The future represents the result of an asynchronous method call. It allows clients to retrieve the result once the operation is complete.</li> </ol>"},{"location":"active-object-pattern/#how-it-works","title":"How It Works","text":"<ol> <li>Client Interaction: The client interacts with the proxy to invoke methods on the active object.</li> <li>Request Queuing: The proxy creates a method request and places it in the activation list managed by the scheduler.</li> <li>Request Scheduling: The scheduler picks up method requests from the activation list and assigns them to worker threads for execution.</li> <li>Method Execution: The worker threads execute the method requests on the servant.</li> <li>Result Handling: If the method request has a return value, the result is stored in a future object, which the client can query to obtain the result once the execution is complete.</li> </ol>"},{"location":"active-object-pattern/#benefits","title":"Benefits","text":"<ul> <li>Improved Responsiveness: By decoupling method invocation from execution, the active object pattern allows the main thread to remain responsive while operations are performed in the background.</li> <li>Scalability: The pattern supports concurrent execution of multiple method requests, making it suitable for scalable applications.</li> <li>Simplified Concurrency Management: The pattern abstracts the complexity of thread management and synchronization, making it easier to implement concurrent operations.</li> </ul> <p>The Active Object design pattern is a powerful tool for managing concurrency in modern C++ applications. By leveraging this pattern, developers can build responsive, scalable, and maintainable systems that efficiently handle concurrent operations.</p>"},{"location":"active-object-pattern/#real-world-applications","title":"Real-World Applications","text":"<p>Here are some real-world applications that use the Active Object design pattern:</p> <ol> <li> <p>Embedded Systems: In embedded systems, such as those used in automotive control systems or industrial automation, the Active Object pattern helps manage concurrent tasks like sensor data processing, actuator control, and communication with other devices.</p> </li> <li> <p>Robotics: Robots often need to perform multiple tasks simultaneously, such as navigating, processing sensor data, and interacting with their environment. The Active Object pattern allows these tasks to be handled concurrently without blocking the main control loop.</p> </li> <li> <p>Graphical User Interfaces (GUIs): GUI applications, such as desktop software or mobile apps, use the Active Object pattern to keep the user interface responsive while performing background tasks like data loading, network communication, or complex computations.</p> </li> <li> <p>Network Servers: Servers that handle multiple client requests concurrently, such as web servers, database servers, or game servers, use the Active Object pattern to manage incoming requests and perform operations without blocking other clients.</p> </li> <li> <p>Telecommunications Systems: In telecommunications, systems like call processing, message routing, and network management require handling multiple concurrent operations. The Active Object pattern helps manage these tasks efficiently.</p> </li> <li> <p>Financial Systems: Trading platforms and financial applications often need to process multiple transactions and market data feeds concurrently. The Active Object pattern ensures that these operations are handled efficiently without blocking the main processing thread.</p> </li> <li> <p>Simulation Systems: Simulation software, such as those used in scientific research or virtual environments, often requires concurrent execution of multiple simulation tasks. The Active Object pattern helps manage these tasks and ensures smooth operation.</p> </li> </ol> <p>By using the Active Object design pattern, these applications can achieve improved responsiveness,  scalability, and simplified concurrency management, making them more efficient and maintainable.</p>"},{"location":"active-object-pattern/#common-challenges","title":"Common Challenges","text":"<p>Implementing the Active Object design pattern can present several challenges:</p> <ol> <li> <p>Complexity: The pattern introduces additional components such as proxies, schedulers, and activation lists, which can increase the complexity of the system. Managing these components effectively requires careful design and implementation.</p> </li> <li> <p>Performance Overhead: The use of proxies and method requests can introduce performance overhead due to the additional layers of abstraction and the need to manage queues and threads. This overhead can impact the overall performance of the system if not managed properly.</p> </li> <li> <p>Thread Management: Efficiently managing threads and ensuring that they are properly synchronized can be challenging. Poor thread management can lead to issues such as deadlocks, race conditions, and thread starvation.</p> </li> <li> <p>Latency: The decoupling of method invocation from execution can introduce latency, especially if the activation list becomes a bottleneck. Ensuring that method requests are processed in a timely manner is crucial for maintaining system responsiveness.</p> </li> <li> <p>Error Handling: Handling errors and exceptions in an asynchronous environment can be more complex than in a synchronous one. Ensuring that errors are properly propagated and handled requires careful design.</p> </li> <li> <p>Resource Management: Managing resources such as memory and file handles in a concurrent environment can be challenging. Ensuring that resources are properly allocated and released is crucial to prevent resource leaks and ensure system stability.</p> </li> <li> <p>Testing and Debugging: Testing and debugging concurrent systems can be more difficult than testing and debugging single-threaded systems. Ensuring that the system behaves correctly under various conditions requires thorough testing and effective debugging tools.</p> </li> <li> <p>Scalability: While the Active Object pattern can improve scalability, ensuring that the system scales effectively with increasing load requires careful design and tuning. Balancing the load across multiple threads and managing the activation list efficiently are key factors in achieving scalability.</p> </li> </ol>"},{"location":"active-object-pattern/#best-practices","title":"Best Practices","text":"<p>By being aware of these challenges and addressing them during the design and implementation phases, developers can effectively leverage the benefits of the Active Object design pattern while minimizing potential issues.</p> <p>Here are some best practices for implementing the Active Object design pattern:</p> <ol> <li> <p>Design Clear Interfaces: Define clear and concise interfaces for the proxy and servant. This helps in maintaining a clean separation of concerns and makes the system easier to understand and maintain.</p> </li> <li> <p>Efficient Thread Management: Use thread pools to manage worker threads efficiently. This helps in reducing the overhead of creating and destroying threads and ensures that resources are utilized effectively.</p> </li> <li> <p>Minimize Latency: Optimize the activation list to ensure that method requests are processed promptly. Consider using priority queues if certain requests need to be handled with higher priority.</p> </li> <li> <p>Robust Error Handling: Implement comprehensive error handling and logging mechanisms. Ensure that exceptions are properly propagated and handled to prevent the system from entering an inconsistent state.</p> </li> <li> <p>Resource Management: Use smart pointers and RAII (Resource Acquisition Is Initialization) principles to manage resources such as memory and file handles. This helps in preventing resource leaks and ensures that resources are released properly.</p> </li> <li> <p>Concurrency Control: Use synchronization mechanisms such as mutexes, condition variables, and atomic operations to manage access to shared resources. Ensure that critical sections are well-defined and minimize their scope to reduce contention.</p> </li> <li> <p>Testing and Debugging: Develop thorough unit tests and integration tests to cover various scenarios, including edge cases and error conditions. Use debugging tools and techniques such as logging, breakpoints, and thread analyzers to diagnose and resolve issues.</p> </li> <li> <p>Scalability Considerations: Design the system to scale horizontally by distributing the load across multiple instances of the active object. Use load balancing techniques to ensure that the system can handle increasing loads effectively.</p> </li> <li> <p>Documentation: Document the design and implementation of the active object pattern in your system. This includes the roles of various components, the flow of method requests, and any assumptions or constraints.</p> </li> <li> <p>Performance Monitoring: Continuously monitor the performance of the system to identify bottlenecks and optimize as needed. Use profiling tools to measure the performance of different components and make data-driven decisions for optimization.</p> </li> </ol> <p>By following these best practices, you can effectively implement the Active Object design pattern and build responsive, scalable, and maintainable concurrent systems.</p>"},{"location":"active-object-pattern/#compatible-design-patterns","title":"Compatible Design Patterns","text":"<p>Several design patterns that are compatible and complement the Active Object design pattern, enhancing its functionality and addressing specific concerns. Here are some common ones:</p> <ol> <li> <p>Proxy Pattern: The Proxy pattern is often used in conjunction with the Active Object pattern to provide a surrogate or placeholder for another object. The proxy handles method invocations and forwards them to the scheduler.</p> </li> <li> <p>Command Pattern: The Command pattern encapsulates a request as an object, allowing parameterization of clients with queues, requests, and operations. This pattern is useful for creating method requests in the Active Object pattern.</p> </li> <li> <p>Future Pattern: The Future pattern is used to represent the result of an asynchronous computation. It allows clients to retrieve the result once the computation is complete, which is essential for handling asynchronous method calls in the Active Object pattern.</p> </li> <li> <p>Scheduler Pattern: The Scheduler pattern manages the execution of tasks, ensuring that they are executed in a controlled manner. This pattern is integral to the Active Object pattern, where the scheduler manages the activation list and dispatches method requests.</p> </li> <li> <p>Observer Pattern: The Observer pattern allows an object to notify other objects about changes in its state. This pattern can be used to notify clients about the completion of method requests or changes in the state of the active object.</p> </li> <li> <p>Singleton Pattern: The Singleton pattern ensures that a class has only one instance and provides a global point of access to it. This pattern can be used to manage the scheduler or other central components in the Active Object pattern.</p> </li> <li> <p>Strategy Pattern: The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern can be used to implement different scheduling strategies for the Active Object pattern.</p> </li> <li> <p>Adapter Pattern: The Adapter pattern allows incompatible interfaces to work together. It can be used to adapt existing components to work with the Active Object pattern without modifying their code.</p> </li> <li> <p>Decorator Pattern: The Decorator pattern allows behavior to be added to individual objects, dynamically, without affecting the behavior of other objects from the same class. This pattern can be used to add additional functionality to method requests or the active object itself.</p> </li> </ol> <p>By combining these design patterns with the Active Object pattern, you can create more robust, flexible, and maintainable concurrent systems.</p>"}]}